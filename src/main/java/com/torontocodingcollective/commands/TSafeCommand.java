package com.torontocodingcollective.commands;

import com.torontocodingcollective.TConst;
import com.torontocodingcollective.TUtil;
import com.torontocodingcollective.oi.TOi;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj2.command.CommandBase;

/**
 * TSafeCommand
 * <p>
 * This command is used as a base command for all other commands and supports
 * the features: <ls>
 * <li>end the command after a given timeout
 * <li>end the command when cancelled by the user </ls>
 */
public abstract class TSafeCommand extends CommandBase {

	private final double timeout;
	private long startTime = 0;

	/**
	 * TSafeCommand
	 * <p>
	 * Construct a safe command with the default timeout
	 * {@link TConst#DEFAULT_COMMAND_TIMEOUT }
	 *
	 * @param oi
	 *            the TOi object that defines the cancel operation
	 *            {@link TOi#getCancelCommand()}
	 */
	public TSafeCommand() {
		this(TConst.DEFAULT_COMMAND_TIMEOUT);
	}

	/**
	 * TSafeCommand
	 * <p>
	 * Construct a safe command with unlimited timeout
	 *
	 * @param timeout
	 *            the time after which this command will end automatically a value
	 *            of {@link TConst#NO_COMMAND_TIMEOUT} will be used as an infinite
	 *            timeout.
	 * @param oi
	 *            the TOi object that defines the cancel operation
	 *            {@link TOi#getCancelCommand()}
	 */
	public TSafeCommand(double timeout) {
		this.timeout = timeout;
	}

	/**
	 * Get the command name associated with this command
	 * @return
	 */
	protected abstract String getCommandName();

	protected String getParmDesc() {
		if (timeout >= 0) {
			return "Timeout" + timeout;
		}
		else {
			return "No timeout";
		}
	}

	/**
	 * Log a message generated by any command
	 * <p>
	 * The message will be marked with the current period
	 * and the estimated time remaining in the period
	 * @param message to log
	 */
	protected void logMessage(String message) {

		// Mark the message with the time and command name
		StringBuilder sb = new StringBuilder();
		if (DriverStation.isAutonomous()) {
			sb.append("Auto: ");
		}
		else {
			sb.append("Teleop: ");
		}

		// Round the match time to one decimal
		double matchTime = TUtil.round(DriverStation.getMatchTime(), 2);
		sb.append(matchTime).append(' ');

		sb.append(getCommandName()).append(" : ");

		sb.append(message);

		System.out.println(sb.toString());
	}

	@Override
	public void initialize() {

		startTime = System.currentTimeMillis();
	}

	@Override
	public boolean isFinished() {

		double timeSinceInitialized = ((double)(System.currentTimeMillis() - startTime)) / 1000;

		if (timeSinceInitialized > timeout) {
			logMessage("command timed out after " + timeSinceInitialized + "s");
			return true;
		}

		return false;
	}

	@Override
	public void end(boolean interrupted) {
		if (interrupted) {
			logMessage("interrupted");
		}
	}
}
